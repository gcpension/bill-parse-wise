import { ManualPlan } from '@/data/manual-plans';
import { UserProfile, PersonalizedRecommendationEngine, PersonalizedRecommendation } from './personalizedRecommendations';

export interface AutoGeneratedProfile {
  profile: UserProfile;
  confidence: number;
  source: string;
}

export interface RecommendationParameter {
  name: string;
  value: string;
  weight: number;
  icon: string;
  description: string;
}

export interface RecommendationExplanation {
  profileSummary: string;
  keyParameters: RecommendationParameter[];
  matchReasons: string[];
  confidenceLevel: number;
}

/**
 * Smart Recommendations Engine - Generates personalized recommendations without explicit user input
 * Uses existing data (category, current bill, time of day, etc.) to infer user needs
 */
export class SmartRecommendationsEngine {
  
  /**
   * Generate automatic user profile from minimal data
   */
  static generateAutoProfile(
    currentMonthlyBill: number,
    category: string,
    timeOfDay?: 'morning' | 'day' | 'evening' | 'night'
  ): AutoGeneratedProfile {
    console.log('ğŸ¤– Generating automatic profile:', { currentMonthlyBill, category, timeOfDay });
    
    // Infer family size from budget
    let familySize = 2;
    let homeType: 'apartment' | 'house' | 'student' | 'business' = 'apartment';
    
    if (category === 'electricity' || category === '×—×©××œ') {
      if (currentMonthlyBill > 500) {
        familySize = 5;
        homeType = 'house';
      } else if (currentMonthlyBill > 300) {
        familySize = 4;
      } else if (currentMonthlyBill > 200) {
        familySize = 3;
      } else if (currentMonthlyBill < 100) {
        familySize = 1;
      }
    } else if (category === 'cellular' || category === '×¡×œ×•×œ×¨' || category === 'mobile') {
      if (currentMonthlyBill > 300) {
        familySize = 5;
      } else if (currentMonthlyBill > 200) {
        familySize = 4;
      } else if (currentMonthlyBill > 150) {
        familySize = 3;
      } else if (currentMonthlyBill < 50) {
        familySize = 1;
      }
    } else if (category === 'internet' || category === '××™× ×˜×¨× ×˜') {
      // Internet doesn't scale much with family, but heavy users pay more
      if (currentMonthlyBill > 150) {
        familySize = 4;
      } else if (currentMonthlyBill > 100) {
        familySize = 3;
      }
    } else if (category === 'tv' || category === '×˜×œ×•×•×™×–×™×”') {
      if (currentMonthlyBill > 250) {
        familySize = 4;
      } else if (currentMonthlyBill > 150) {
        familySize = 3;
      }
    }
    
    // Infer usage level from spending
    let usageLevel: 'light' | 'medium' | 'heavy' | 'extreme' = 'medium';
    const avgBudget = this.getAverageBudgetForCategory(category);
    const ratio = currentMonthlyBill / avgBudget;
    
    if (ratio > 1.5) {
      usageLevel = 'extreme';
    } else if (ratio > 1.2) {
      usageLevel = 'heavy';
    } else if (ratio < 0.7) {
      usageLevel = 'light';
    }
    
    // Infer usage time from current time
    const usageHours = timeOfDay || this.inferTimeOfDay();
    
    // Infer work from home from time and usage
    const workFromHome = usageHours === 'day' && usageLevel !== 'light';
    
    // Category-specific default priorities
    const priorities = this.getCategoryDefaultPriorities(category);
    
    // Build profile
    const profile: UserProfile = {
      familySize,
      homeType,
      monthlyBudget: currentMonthlyBill > 0 ? currentMonthlyBill : avgBudget,
      currentMonthlySpend: currentMonthlyBill,
      currentProvider: '×œ× ×™×“×•×¢',
      priceFlexibility: currentMonthlyBill > 0 ? 'flexible' : 'strict',
      usageLevel,
      usageHours,
      workFromHome,
      streamingHeavy: usageLevel === 'heavy' || usageLevel === 'extreme',
      gamingHeavy: usageLevel === 'extreme',
      priorities,
      contractFlexibility: 'doesnt_matter',
      technologyPreference: 'stable',
      supportImportance: 'important',
    };
    
    // Confidence based on available data
    let confidence = 0.65; // Base confidence
    if (currentMonthlyBill > 0) confidence += 0.15;
    if (timeOfDay) confidence += 0.05;
    
    return {
      profile,
      confidence,
      source: 'auto-inferred from usage data'
    };
  }
  
  /**
   * Get average budget for category
   */
  private static getAverageBudgetForCategory(category: string): number {
    const categoryKey = this.normalizeCategoryKey(category);
    
    const averages: Record<string, number> = {
      'electricity': 250,
      '×—×©××œ': 250,
      'internet': 100,
      '××™× ×˜×¨× ×˜': 100,
      'cellular': 150,
      '×¡×œ×•×œ×¨': 150,
      'mobile': 150,
      'tv': 180,
      '×˜×œ×•×•×™×–×™×”': 180,
    };
    
    return averages[categoryKey] || 200;
  }
  
  /**
   * Get category-specific default priorities
   */
  private static getCategoryDefaultPriorities(category: string): UserProfile['priorities'] {
    const categoryKey = this.normalizeCategoryKey(category);
    
    // Default priorities per category
    const defaults: Record<string, UserProfile['priorities']> = {
      'electricity': {
        price: 5,
        reliability: 5,
        speed: 2,
        customerService: 3,
        flexibility: 3,
        features: 2,
        brandTrust: 4,
        innovation: 2,
      },
      '×—×©××œ': {
        price: 5,
        reliability: 5,
        speed: 2,
        customerService: 3,
        flexibility: 3,
        features: 2,
        brandTrust: 4,
        innovation: 2,
      },
      'internet': {
        price: 4,
        reliability: 5,
        speed: 5,
        customerService: 3,
        flexibility: 3,
        features: 3,
        brandTrust: 3,
        innovation: 3,
      },
      '××™× ×˜×¨× ×˜': {
        price: 4,
        reliability: 5,
        speed: 5,
        customerService: 3,
        flexibility: 3,
        features: 3,
        brandTrust: 3,
        innovation: 3,
      },
      'cellular': {
        price: 5,
        reliability: 4,
        speed: 4,
        customerService: 3,
        flexibility: 4,
        features: 3,
        brandTrust: 3,
        innovation: 2,
      },
      '×¡×œ×•×œ×¨': {
        price: 5,
        reliability: 4,
        speed: 4,
        customerService: 3,
        flexibility: 4,
        features: 3,
        brandTrust: 3,
        innovation: 2,
      },
      'mobile': {
        price: 5,
        reliability: 4,
        speed: 4,
        customerService: 3,
        flexibility: 4,
        features: 3,
        brandTrust: 3,
        innovation: 2,
      },
      'tv': {
        price: 4,
        reliability: 4,
        speed: 2,
        customerService: 4,
        flexibility: 3,
        features: 5,
        brandTrust: 3,
        innovation: 3,
      },
      '×˜×œ×•×•×™×–×™×”': {
        price: 4,
        reliability: 4,
        speed: 2,
        customerService: 4,
        flexibility: 3,
        features: 5,
        brandTrust: 3,
        innovation: 3,
      },
    };
    
    return defaults[categoryKey] || {
      price: 4,
      reliability: 4,
      speed: 3,
      customerService: 3,
      flexibility: 3,
      features: 3,
      brandTrust: 3,
      innovation: 3,
    };
  }
  
  /**
   * Normalize category key to handle both Hebrew and English
   */
  private static normalizeCategoryKey(category: string): string {
    const normalized = category.toLowerCase().trim();
    const mapping: Record<string, string> = {
      '×—×©××œ': 'electricity',
      'electricity': 'electricity',
      '××™× ×˜×¨× ×˜': 'internet',
      'internet': 'internet',
      '×¡×œ×•×œ×¨': 'cellular',
      'cellular': 'cellular',
      'mobile': 'cellular',
      '×˜×œ×•×•×™×–×™×”': 'tv',
      'tv': 'tv',
    };
    return mapping[normalized] || normalized;
  }
  
  /**
   * Infer time of day from current time
   */
  private static inferTimeOfDay(): 'morning' | 'day' | 'evening' | 'night' {
    const hour = new Date().getHours();
    
    if (hour >= 6 && hour < 12) return 'morning';
    if (hour >= 12 && hour < 18) return 'day';
    if (hour >= 18 && hour < 23) return 'evening';
    return 'night';
  }
  
  /**
   * Generate explanation for the recommendation
   */
  static generateExplanation(
    profile: UserProfile,
    category: string,
    confidence: number
  ): RecommendationExplanation {
    const categoryKey = this.normalizeCategoryKey(category);
    const categoryHebrew = this.getCategoryHebrewName(categoryKey);
    
    // Profile summary
    const profileSummary = `××©×¤×—×” ×©×œ ${profile.familySize} × ×¤×©×•×ª ×¢× ×ª×§×¦×™×‘ ×©×œ â‚ª${profile.monthlyBudget} ×œ×—×•×“×©`;
    
    // Build key parameters
    const keyParameters: RecommendationParameter[] = [];
    
    // Family size parameter
    keyParameters.push({
      name: '×’×•×“×œ ××©×¤×—×”',
      value: `${profile.familySize} × ×¤×©×•×ª`,
      weight: 0.25,
      icon: 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦',
      description: profile.familySize >= 4 
        ? '××©×¤×—×” ×’×“×•×œ×” - ×¦×¨×™×›×” ×’×‘×•×”×” ×¦×¤×•×™×”'
        : profile.familySize >= 3
        ? '××©×¤×—×” ×‘×™× ×•× ×™×ª - ×¦×¨×™×›×” ×¡×˜× ×“×¨×˜×™×ª'
        : '××©×¤×—×” ×§×˜× ×”/×™×—×™×“ - ×¦×¨×™×›×” ×—×¡×›×•× ×™×ª'
    });
    
    // Budget parameter
    const avgBudget = this.getAverageBudgetForCategory(category);
    const budgetRatio = profile.monthlyBudget / avgBudget;
    keyParameters.push({
      name: '×ª×§×¦×™×‘ ×—×•×“×©×™',
      value: `â‚ª${profile.monthlyBudget}`,
      weight: 0.30,
      icon: 'ğŸ’°',
      description: budgetRatio > 1.2
        ? '×ª×§×¦×™×‘ ×’×‘×•×” - ××—×¤×© ×¤×™×ª×¨×•×Ÿ ×¤×¨×™××™×•×'
        : budgetRatio > 0.8
        ? '×ª×§×¦×™×‘ ×¡×˜× ×“×¨×˜×™ - ××™×–×•×Ÿ ×‘×™×Ÿ ××—×™×¨ ×œ××™×›×•×ª'
        : '×ª×§×¦×™×‘ × ××•×š - ××—×¤×© ×—×™×¡×›×•×Ÿ ××§×¡×™××œ×™'
    });
    
    // Usage level parameter
    keyParameters.push({
      name: '×¨××ª ×©×™××•×©',
      value: profile.usageLevel === 'extreme' ? '×’×‘×•×”×” ×××•×“' 
        : profile.usageLevel === 'heavy' ? '×’×‘×•×”×”'
        : profile.usageLevel === 'medium' ? '×‘×™× ×•× ×™×ª'
        : '× ××•×›×”',
      weight: 0.20,
      icon: 'ğŸ“Š',
      description: profile.usageLevel === 'extreme'
        ? '×©×™××•×© ××™× ×˜× ×¡×™×‘×™ - × ×“×¨×© ×¤×ª×¨×•×Ÿ ×¢× ××©××‘×™× ×’×“×•×œ×™×'
        : profile.usageLevel === 'heavy'
        ? '×©×™××•×© ×’×‘×•×” - × ×“×¨×© ×¤×ª×¨×•×Ÿ ××™×›×•×ª×™'
        : profile.usageLevel === 'medium'
        ? '×©×™××•×© ×¡×˜× ×“×¨×˜×™ - ××¡×œ×•×œ ×‘×¡×™×¡×™ ××¡×¤×§'
        : '×©×™××•×© × ××•×š - ××¡×œ×•×œ ×—×¡×›×•× ×™'
    });
    
    // Category-specific priority
    const topPriority = this.getTopPriorityForCategory(categoryKey, profile.priorities);
    keyParameters.push({
      name: '×¢×“×™×¤×•×ª ×¨××©×™×ª',
      value: topPriority.name,
      weight: 0.25,
      icon: topPriority.icon,
      description: topPriority.description
    });
    
    // Match reasons based on profile
    const matchReasons: string[] = [];
    
    if (budgetRatio < 0.9) {
      matchReasons.push('ğŸ’¡ ×—×™×¡×›×•×Ÿ ××©××¢×•×ª×™ ×‘×¢×œ×•×™×•×ª ×”×—×•×“×©×™×•×ª');
    }
    
    if (profile.familySize >= 4) {
      matchReasons.push('ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ××ª××™× ×œ××©×¤×—×•×ª ×’×“×•×œ×•×ª ×¢× ×¦×¨×™×›×” ×’×‘×•×”×”');
    }
    
    if (profile.usageLevel === 'extreme' || profile.usageLevel === 'heavy') {
      matchReasons.push('ğŸ“¡ ××¡×¤×§ ×‘×™×¦×•×¢×™× ×’×‘×•×”×™× ×œ××©×ª××©×™× ×›×‘×“×™×');
    }
    
    if (categoryKey === 'electricity' || categoryKey === '×—×©××œ') {
      matchReasons.push('âš¡ ×—×‘×¨×” ×××™× ×” ×¢× ×©×™×¨×•×ª ×™×¦×™×‘');
    }
    
    if (categoryKey === 'internet' || categoryKey === '××™× ×˜×¨× ×˜') {
      matchReasons.push('ğŸš€ ××”×™×¨×•×™×•×ª ×’×‘×•×”×•×ª ×œ×’×œ×™×©×” ×—×œ×§×”');
    }
    
    if (categoryKey === 'cellular') {
      matchReasons.push('ğŸ“± ×›×™×¡×•×™ ×¨×—×‘ ×‘×¨×—×‘×™ ×”××¨×¥');
    }
    
    if (profile.workFromHome) {
      matchReasons.push('ğŸ  ××•×ª×× ×œ×¢×‘×•×“×” ××”×‘×™×ª');
    }
    
    return {
      profileSummary,
      keyParameters,
      matchReasons,
      confidenceLevel: confidence
    };
  }
  
  /**
   * Get Hebrew name for category
   */
  private static getCategoryHebrewName(categoryKey: string): string {
    const names: Record<string, string> = {
      'electricity': '×—×©××œ',
      'internet': '××™× ×˜×¨× ×˜',
      'cellular': '×¡×œ×•×œ×¨',
      'tv': '×˜×œ×•×•×™×–×™×”'
    };
    return names[categoryKey] || categoryKey;
  }
  
  /**
   * Get top priority for category
   */
  private static getTopPriorityForCategory(
    categoryKey: string,
    priorities: UserProfile['priorities']
  ): { name: string; icon: string; description: string } {
    // Find highest priority
    const entries = Object.entries(priorities);
    entries.sort((a, b) => b[1] - a[1]);
    const topKey = entries[0][0];
    
    const priorityMap: Record<string, { name: string; icon: string; description: string }> = {
      'price': {
        name: '××—×™×¨ × ××•×š',
        icon: 'ğŸ’°',
        description: '××—×¤×© ××ª ×”××—×™×¨ ×”×˜×•×‘ ×‘×™×•×ª×¨ ×‘×©×•×§'
      },
      'reliability': {
        name: '×××™× ×•×ª',
        icon: 'ğŸ”’',
        description: '×—×©×•×‘ ×©×”×©×™×¨×•×ª ×™×”×™×” ×™×¦×™×‘ ×•×œ×œ× ×ª×§×œ×•×ª'
      },
      'speed': {
        name: '××”×™×¨×•×ª',
        icon: 'âš¡',
        description: '××—×¤×© ×‘×™×¦×•×¢×™× ×’×‘×•×”×™× ×•××”×™×¨×•×™×•×ª ××§×¡×™××œ×™×•×ª'
      },
      'customerService': {
        name: '×©×™×¨×•×ª ×œ×§×•×—×•×ª',
        icon: 'ğŸ§',
        description: '×—×©×•×‘ ×©×™×”×™×” ×ª××™×›×” ×˜×•×‘×” ×•×–××™× ×”'
      },
      'flexibility': {
        name: '×’××™×©×•×ª',
        icon: 'ğŸŒŸ',
        description: '×¨×•×¦×” ×—×•×¤×© ×œ×©× ×•×ª ×œ×œ× ×”×ª×—×™×™×‘×•×ª ××¨×•×›×”'
      },
      'features': {
        name: '×ª×›×•× ×•×ª',
        icon: 'âœ¨',
        description: '××—×¤×© ××¡×œ×•×œ ×¢×©×™×¨ ×‘×ª×›×•× ×•×ª ×•××¤×©×¨×•×™×•×ª'
      },
      'brandTrust': {
        name: '××•× ×™×˜×™×Ÿ',
        icon: 'â­',
        description: '××¢×“×™×£ ×—×‘×¨×•×ª ××•×›×¨×•×ª ×•××”×™×× ×•×ª'
      },
      'innovation': {
        name: '×—×“×©× ×•×ª',
        icon: 'ğŸš€',
        description: '××—×¤×© ×˜×›× ×•×œ×•×’×™×•×ª ×—×“×©×•×ª ×•××ª×§×“××•×ª'
      }
    };
    
    return priorityMap[topKey] || priorityMap['price'];
  }
  
  /**
   * Generate automatic recommendations from minimal data
   */
  static generateAutoRecommendations(
    plans: ManualPlan[],
    currentMonthlyBill: number,
    category: string,
    limit: number = 3
  ): { recommendations: PersonalizedRecommendation[]; explanation: RecommendationExplanation } {
    console.log('ğŸ¯ Generating auto recommendations:', { 
      plansCount: plans.length, 
      currentMonthlyBill, 
      category,
      limit 
    });
    
    // Generate automatic profile
    const { profile, confidence } = this.generateAutoProfile(currentMonthlyBill, category);
    
    console.log('ğŸ“Š Generated profile:', {
      familySize: profile.familySize,
      budget: profile.monthlyBudget,
      usageLevel: profile.usageLevel,
      confidence
    });
    
    // Use existing recommendation engine with auto-generated profile
    const recommendations = PersonalizedRecommendationEngine.generatePersonalizedRecommendations(
      plans,
      profile,
      this.normalizeCategoryKey(category)
    );
    
    // Adjust confidence levels
    recommendations.forEach(rec => {
      rec.confidenceLevel = Math.min(rec.confidenceLevel * confidence, 0.85);
    });
    
    // Return top N recommendations with explanation
    const topRecommendations = recommendations.slice(0, limit);
    
    // Generate explanation
    const explanation = this.generateExplanation(profile, category, confidence);
    
    console.log('âœ… Generated top recommendations:', 
      topRecommendations.map(r => ({
        company: plans.find(p => p.id === r.planId)?.company,
        score: r.personalizedScore,
        confidence: r.confidenceLevel
      }))
    );
    
    return { recommendations: topRecommendations, explanation };
  }
}
